#### JS运行机制

##### 1.浏览器线程

浏览器的线程：

1. JS引擎线程
2. UI渲染线程
3. 浏览器事件触发线程
4. http请求线程
5. EventLoop轮询的处理线程

这些线程的作用：

1. JS线程用于执行JS任务
2. UI线程用于渲染页面
3. 浏览器事件触发线程用于控制交互，响应用户
4. http线程用于处理请求，ajax是委托给浏览器新开一个http线程
5. EventLoop处理线程用于轮询消息队列

浏览器中的JS任务：

- 执行JS代码
- 对用户的输入（包含鼠标点击、键盘输入等）做出反应
- 处理异步的网络请求

##### 2.JS单线程

- 单线程是指JS只能在一个线程上运行（JS同时只能执行一个JS任务，其他的任务则排队等候执行）。
- **JS**是单线程的，但**JS引擎**有多个线程，一个主线程，其他的线程后台配合主线程。
- 浏览器端的JS会操作DOM，多个线程必然会带来同步的问题，所以JS选择了单线程。
- JS可以操作DOM，影响渲染，所以JS引擎线程和UI线程存在互斥，这也就解释了为什么JS执行时会阻塞页面的渲染。

##### 3.消息队列（任务队列）

**JS运行时，除了一个运行线程，引擎还提供一个消息队列，里面是各种需要当前程序处理的消息。新的消息进入队列的时候，会自动排在队列的尾端（消息与回调函数相互联系）**。

单线程意味着JS任务需要排队，如果前一个任务出现大量的耗时操作，后面的任务得不到执行，任务的积累会导致页面的“假死”。这也是JS编程一直在强调需要回避地“坑”。

##### 4.JS任务

- 同步任务：在主线程排队支持的任务，前一个任务执行完毕后，执行后一个任务，形成一个执行栈，线程执行时在内存形成的空间为栈，执行栈可以实现函数的层次调用。
- 异步任务：异步任务会被主线程挂起，不会进入主线程，而是进入消息队列，而且必须指定回调函数，只有消息队列通知主线程，并且执行栈为空时，该消息对应的任务才会进入执行栈获得执行的机会。

##### 5.事件和回调函数

- 消息队列是一个事件的队列，IO响应时，会往队列中添加一个消息，此时说明相关的异步代码到了执行的时机，可以进入主线程的执行栈了。
- 主线程读取消息队列，可以读取到对应的事件。
- 消息队列可以响应IO事件，还有用户产生的事件（比如点击鼠标，页面滚动），只要指定了回调函数，就会进入消息队列，等待EventLoop轮询线程处理，是否可以进入主线程的执行栈。
- 消息和回调函数相互联系的含义：主线程读到消息，就会执行相应的回调函数。进入消息队列的消息，必须对应相应的回调函数，否则这个消息就会被丢弃而不会进入消息队列。
- 消息队列是一个先进先出的队列结构，这就决定了它的执行顺序，先产生的消息会被主线程先读取，会不会执行则会检查一下执行时间，因为存在setTimeout等定时函数，这类事件产生的消息进入到消息队列，被执行的时机取决于它在队列中的位置和执行时间

##### 6.EventLoop

**主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为“EventLoop(事件循环)”**

简单地说，浏览器的两个线程：一个负责程序本身的运行，称为“主线程”；另一个负责主线程与其它线程（主要是各种I/O操作）的通信，被称为"EventLoop线程"

异步代码的执行逻辑：

每当遇到I/O的时候，主线程就让EventLoop线程去通知相应的I/O程序，然后接着往后运行，所以不存在等待时间。等到I/O程序完完成操作，EventLoop线程把消息添加到消息队列，主线程就调用事先设定的回调函数，完成整个任务。

- JavaIO中包括了网络IO，我们通常把http请求归类为网络IO。
- JS的AJAX是new XMLHttpRequest()对象实现的，浏览器会新开一个线程来处理http请求，这就是AJAX能够实现局部刷新的同时，还能响应用户交互的原因。
